'''Distinct powers
Problem 29

Consider all integer combinations of a^b for 2 <= a <= 5 and 2 <= b <= 5:

    2^2=4, 2^3=8, 2^4=16, 2^5=32
    3^2=9, 3^3=27, 3^4=81, 3^5=243
    4^2=16, 4^3=64, 4^4=256, 4^5=1024
    5^2=25, 5^3=125, 5^4=625, 5^5=3125

If they are then placed in numerical order, with any repeats removed, we get the following sequence of 15 distinct terms:

4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024, 3125

How many distinct terms are in the sequence generated by a^b for 2 <= a,b <= 100?'''

'''My idea is to do this without actually computing any values. We iterate for a in 2..100, then for each a, iterate for b in 2..100. For each a^b, check to see if we have bookmarked the pair a^b. If we have, skip. If not, then observe that for a,b,c,d\in {2,...,100}, with a<c, if a^b = c^d, then a and c must have precisely the same prime factors, and that there must be a positive integer r for which b = dr; this r manifests as a^r = c. Thus, to be specific, if we check 4^2, it will be in the list (as it would have been marked when processing 2^4). 3^6, however, would not be found on the list. We would thus mark 9^3,  27^2, and 81^1.

   This is, of course, not exactly correct. The problem lies with numbers possessing prime factors p^k, for k>1. Example: 4^12, in our discussion above, will also pick up 16^6 and 64^4. But it doesn't pick up 8^8, which it should. So what I really need is the prime factorization of a as a = p_1^{k_1} \cdots p_u^{k_u}. Then I let d = gcd(k_1,\ldots,k_u), then iterate over f, starting with f=d+1, until f/d < 2.'''

import math

def gcd_pair(a,b):
	while b > 0:
		a, b = b, a % b
	return a

def gcd_list(list_ints):
	if len(list_ints) == 1:
		return list_ints[0]
	else:
		a = list_ints.pop()
		b = list_ints.pop()
		list_ints.append(gcd_pair(a,b))
		return gcd_list(list_ints)


def prime_factors(n):
	pf = {}
	for d in range(2, n+1):
		if n % d == 0:
			ctr = 0
			while n % d == 0:
				ctr += 1
				n = int(n/d)
			pf[d] = ctr
		if n == 1: break
	return pf

min_val = 2
max_val = 100




dupes = []
for a in range(min_val, max_val + 1):
	for b in range(min_val, max_val + 1):
		if (a,b) not in dupes:
			looper = True
			denom = gcd_list(prime_factors(a).values())
			d = denom + 1
			while d < b:
				u, v = int(a**(float(d)/float(denom))), int(b*denom/d)
				if u > max_val or v < 2:
					break
				else:
					if (b * denom) % d == 0:
						if (u,v) not in dupes:
							dupes.append((u,v))
					d += 1


print(len(list(set(dupes))))
print(len(dupes))

print (max_val - min_val + 1)**2 - len(list(set(dupes)))